在如今，时间复杂度（不算时间，算次数）和空间复杂度（不算空间，算变量个数）中更看重时间复杂度。因为硬件配置的不断提高。

时间复杂度：不是计算具体的时间，跑了多少秒。算的是操作次数（一个算法所花费的时间与与其中语句的执行次数成正比例），执行次数为算法的时间复杂度。
如果一个程序所执行的次数是N*N+2*N+10（n是变量，未知数）,但实际没必要算这么精确，因为随着n的增大，这个表达式中n*n对结果的影响是最大的。
------------故时间复杂度是一个估算，是看表达式中影响最大的那一项。

使用的是大O的渐进表示法（估算），故上式的时间复杂度是：O（N^2)
大O渐进表示法推导：1.用常数1取代运行中的所有加法常数，2.在修改后的运行次数函数中，只保留最高阶项，3.如果最高阶项存在且不是1（就把所有1去掉），则去除与这个项目相乘的常数。得到结果就是大O阶
O（1）就是时间复杂度是常数次，不会随着变量变量变大而变大。效率不变。
另外有些算法复杂度是分最好，平均和最坏情况的：
最坏：任意输入规模的最大运行次数（上界）N
平均：任意输入规模的期望运行次数 N/2
最好：任意输入规模的最小运行次数（下界）1
一般情况关注是算法的最坏运行情况，所以时间复杂度是O（N）--悲观的预期

冒泡排序法：
第一趟：N
第二趟：N-1
......-----等差数列
第N趟：1
总和为：前N项和（N+1)*N/2(准确）
时间复杂度O（N^2)
ps：不是一层循环就是O（n），俩层就是O(N^2),要具体分析。

二分查找（折半查找）：
最好的是O（1）
最坏的是折到最后只剩一个数。（假设找了X次，则次数是1*2*2*2.。。。。*2=N，2^x=N,X=log(N,2)),而算法的复杂度计算时，喜欢省略简写成logN。因为很多地方写不出底数。故O（logN）有些地方写成了O（lgN）-不对的格式。

递归的函数嵌套调用(函数递归比循环效率低，因为函数要建立栈帧）
递归了N次，每次递归运算了常数O（1）次，所以整体式O（N），如果每次递归中有for循环循环N次，则为O（N^2)

常见的时间复杂度：
O(N),O(N^2),O(1),O(logN)
而最优的是O（1），其次是O（logN）因为像10亿人，查找只要10次左右就可以了，2^N=10亿

空间复杂度
是对一个算法过程中的临时占用存储空间的大小的量度，因为最后空间都会销毁所以是计算的是占用空间最多的时候的空间，算的是最坏的情况占用空间，算的是算量的个数，也使用大O渐进法
且时间是累积的，空间是不累计的；
像for循环走了N次用的是同一个空间，且出了作用域就被销毁了，重新进入才会在开辟空间，不会累积
递归是往下递归时空间一直增加，而往上时是空间是一直减小的，在销毁空间的，且每一次函数调用都要开辟栈帧。返回时销毁栈帧。
递归调用了N层,每次调用建立一个栈帧，每个栈帧使用了常数个空间（O(1))

案例：
有1~n所以整数，但是缺了一个数，请找出来。要求O（n）之内
思路一：先排序，快速排序O（logN*N)已经不符合了
思路二：将0~n相加减去数组中的数，得到的即为我们要找的数
思路三：异或（链接https://blog.csdn.net/qq_19272431/article/details/78564391）（相异为1，相同为0）符号^  有一个特点相同的数异或为全0，
如果将1~n依次与数组全部数异或，得出的时---看课件

案例：
旋转数组（课件）
给定一个数组，将数组向右移动k个位置，，k时非负数。
进阶：想出三种方法解决，可以用O（1）的复杂度来解决吗
